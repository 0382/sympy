"""Modules in number fields. """

from sympy import igcd, ilcm
from sympy.core.symbol import Dummy
from sympy.polys import Poly
from sympy.polys.domains import FF, QQ, ZZ
from sympy.polys.matrices import DomainMatrix
from sympy.polys.matrices.exceptions import DMBadInputError
from sympy.polys.matrices.normalforms import hermite_normal_form
from sympy.polys.polyerrors import CoercionFailed
from sympy.polys.polyutils import IntegerPowerable
from .utilities import AlgIntPowers, is_int, is_rat, get_num_denom


def to_col(coeffs):
    """Transform a list of integer coefficients into a column vector."""
    return DomainMatrix([[ZZ(c) for c in coeffs]], (1, len(coeffs)), ZZ).transpose()


class ClosureFailure(Exception):
    """
    Signals that a ModuleElement which was supposed to belong to a certain
    Module, does not in fact belong to it.
    """
    pass


class Module:
    """Generic finitely-generated module."""

    @property
    def n(self):
        """The number of generators of this module."""
        raise NotImplementedError

    def mult_tab(self):
        """The multiplication table for this module (if closed under mult)."""
        raise NotImplementedError

    @property
    def container(self):
        """A larger module, in which this one is regarded as a submodule."""
        return None

    def represent(self, elt):
        """
        Represent an element of an ancestor module as a ZZ-linear combination
        over the generators of this module.
        """
        raise NotImplementedError

    def ancestors(self, include_self=False):
        """
        Return list of ancestors of this module, from largest/oldest to smallest/newest.
        """
        c = self.container
        a = [] if c is None else c.ancestors(include_self=True)
        if include_self:
            a.append(self)
        return a

    def power_basis_ancestor(self):
        """Return the PowerBasis that is an ancestor of this module."""
        if isinstance(self, PowerBasis):
            return self
        c = self.container
        if c is not None:
            return c.power_basis_ancestor()
        return None

    def nearest_common_ancestor(self, other):
        """
        Locate the nearest common ancestor of this Module and another.

        Returns
        =======

        Module or None

        """
        sA = self.ancestors(include_self=True)
        oA = other.ancestors(include_self=True)
        nca = None
        for sa, oa in zip(sA, oA):
            if sa == oa:
                nca = sa
            else:
                break
        return nca

    def is_compat_col(self, col):
        """Say whether *col* is a suitable column vector for this module."""
        return isinstance(col, DomainMatrix) and col.shape == (self.n, 1) and col.domain.is_ZZ

    def __call__(self, spec, denom=1):
        """
        Generate a ModuleElement belonging to this module.

        Parameters
        ==========

        spec: either a compatible column vector, or else an integer ``j``,
          ``0 <= j < self.n``, which we interpret as the jth elementary basis vector.
          In either case, we return the ModuleElement defined by this vector.
        denom: optional denominator for the ModuleElement.

        """
        if isinstance(spec, int) and 0 <= spec < self.n:
            spec = DomainMatrix.eye(self.n, ZZ)[:, spec].to_dense()
        if not self.is_compat_col(spec):
            raise ValueError('Expect compatible column vector specification.')
        return make_mod_elt(self, spec, denom=denom)

    def starts_with_unity(self):
        """Say whether the module's first generator equals unity."""
        raise NotImplementedError

    def basis_elements(self):
        """Get list of ModuleElements being the generators of this module."""
        return [self(j) for j in range(self.n)]

    def zero(self):
        """Return a ModuleElement representing zero."""
        return self(0) * 0

    def one(self):
        """
        Return a ModuleElement representing unity, and belonging to the first
        ancestor of this module (including itself) that starts with unity.
        """
        return self.element_from_rational(1)

    def element_from_rational(self, a):
        """
        Return a ModuleElement representing a rational number.

        The returned ModuleElement will belong to the first module on this
        module's ancestor chain (including this module itself) that starts
        with unity.

        Parameters
        ==========

        a: anything such that ``is_rat(a)`` is ``True``

        Returns
        =======

        ModuleElement

        """
        raise NotImplementedError

    def submodule_from_gens(self, gens, hnf=True, hnf_modulus=None):
        """
        Form the submodule generated by a list of ModuleElements belonging to
        this Module.

        Parameters
        ==========

        gens: list of ModuleElements belonging to this Module.
        hnf: if True, we will reduce the matrix into Hermite normal form before
          forming the Submodule.
        hnf_modulus: optional modulus for use in the HNF reduction algorithm.

        Returns
        =======

        Submodule

        """
        if not all(g.module == self for g in gens):
            raise ValueError('Generators must belong to this module.')
        n = len(gens)
        if n == 0:
            raise ValueError('Need at least one generator.')
        m = gens[0].n
        d = gens[0].denom if n == 1 else ilcm(*[g.denom for g in gens])
        B = DomainMatrix.zeros((m, 0), ZZ).hstack(*[(d // g.denom) * g.col for g in gens])
        if hnf:
            B = hermite_normal_form(B, D=hnf_modulus)
        return self.submodule_from_matrix(B, denom=d)

    def submodule_from_matrix(self, B, denom=1):
        """
        Form the submodule generated by elements of this Module indicated by
        the columns of a matrix, with an optional denominator.

        Parameters
        ==========

        B: DomainMatrix over :ref:`ZZ` whose columns define, along with the denom, the
          elements of this module that generate the submodule. Thus, the number
          of rows of *B* must equal the number of generators of the present module.
        denom: see *B*.

        Returns
        =======

        Submodule

        Raises
        ======

        ValueError if the given matrix *B* is not over :ref:`ZZ` or its dimension is
        mismatched with this module.

        """
        m, n = B.shape
        if not B.domain.is_ZZ:
            raise ValueError('Matrix must be over ZZ.')
        if not m == self.n:
            raise ValueError('Matrix row count must match base module.')
        return make_submodule(self, B, denom=denom)

    def whole_submodule(self):
        """Return a submodule equal to this entire module."""
        B = DomainMatrix.eye(self.n, ZZ)
        return self.submodule_from_matrix(B)

    def endomorphism_ring(self):
        return EndomorphismRing(self)


class PowerBasis(Module):
    """The module generated by the powers of an algebraic integer theta."""

    def __init__(self, T):
        """
        Parameters
        ==========

        T: monic, irreducible, univariate polynomial over :ref:`ZZ`

        """
        self.T = T
        self._n = T.degree()
        self._mult_tab = None

    def __eq__(self, other):
        if isinstance(other, PowerBasis):
            return self.T == other.T
        return NotImplemented

    @property
    def n(self):
        return self._n

    def mult_tab(self):
        if self._mult_tab is None:
            theta_pow = AlgIntPowers(self.T)
            M = {}
            for u in range(self.n):
                M[u] = {}
                for v in range(u, self.n):
                    M[u][v] = theta_pow[u+v]
            self._mult_tab = M
        return self._mult_tab

    def represent(self, elt):
        """
        In our system, to "represent" always means to write a ModuleElement as
        a ``ZZ``-linear combination over the generators of the present Module.
        Furthermore, the incoming ModuleElement must belong to an ancestor of
        the present Module.

        Therefore, when the present Module is a PowerBasis, it is an odd case,
        and one which tends not to arise in practice, except maybe when using a
        ModuleEndomorphism on a PowerBasis.

        In such a case, (1) the incoming ModuleElement must belong to the
        PowerBasis itself (since the latter has no proper ancestors) and
        (2) it is "representable" iff it belongs to ``ZZ[theta]`` (although
        generally PowerBasisElements may represent any element of ``QQ[theta]``,
        i.e. any algebraic number).
        """
        if elt.module == self and elt.denom == 1:
            return elt.column()
        else:
            raise ClosureFailure('Element not representable in ZZ[theta].')

    def starts_with_unity(self):
        return True

    def element_from_rational(self, a):
        return self(0) * a

    def element_from_poly(self, f):
        """
        Produce an element of this module, representing a given polynomial
        after reduction mod our defining minimal polynomial.

        Parameters
        ==========

        f: Poly over :ref:`ZZ` in same var as our defining poly.

        Returns
        =======

        PowerBasisElement

        """
        n, k = self.n, f.degree()
        if k >= n:
            f = f % self.T
        if f == 0:
            return self.zero()
        d, g = f.clear_denoms()
        c = list(reversed(g.rep.rep))
        ell = len(c)
        z = [ZZ(0)] * (n - ell)
        col = to_col(c + z)
        return self(col, denom=ZZ.from_sympy(d))


class Submodule(Module, IntegerPowerable):
    """A submodule of another module."""

    def __init__(self, container, matrix, denom=1, mult_tab=None):
        """
        Parameters
        ==========

        container: the Module in which this one is contained
        matrix: the DomainMatrix over :ref:`ZZ` whose columns define this submodule's
          generators as linear combinations over the container's generators.
        denom: optional denominator.
        mult_tab: optional multiplication table for this module.

        """
        self._container = container
        self._matrix = matrix
        self._denom = denom
        self._mult_tab = mult_tab
        self._n = matrix.shape[1]
        self._QQ_matrix = None

    def __repr__(self):
        r = 'cols' + repr(self.matrix.transpose().to_Matrix().tolist())
        if self.denom > 1:
            r += f'/{self.denom}'
        return r

    def copy(self):
        """Make a copy of this Submodule."""
        return type(self)(self.container, self.matrix.copy(), denom=self.denom, mult_tab=self._mult_tab)

    def reduced(self):
        """Produce a reduced version of this Submodule."""
        if self.denom == 1:
            return self.copy()
        g = igcd(self.denom, *self.coeffs)
        if g == 1:
            return self.copy()
        return type(self)(self.container, (self.matrix / g).convert_to(ZZ), denom=self.denom // g, mult_tab=self._mult_tab)

    def discard_before(self, r):
        """
        Produce a new module by discarding all generators before a given index *r*.
        """
        W = self.matrix[:, r:]
        s = self.n - r
        M = None
        mt = self._mult_tab
        if mt is not None:
            M = {}
            for u in range(s):
                M[u] = {}
                for v in range(u, s):
                    M[u][v] = mt[r + u][r + v][r:]
        return make_submodule(self.container, W, denom=self.denom, mult_tab=M)

    @property
    def n(self):
        return self._n

    def mult_tab(self):
        if self._mult_tab is None:
            self.compute_mult_tab()
        return self._mult_tab

    def compute_mult_tab(self):
        M = {}
        gens = [e.to_container() for e in self.basis_elements()]
        n = self.n
        for u in range(n):
            M[u] = {}
            for v in range(u, n):
                M[u][v] = self.represent(gens[u] * gens[v]).flat()
        self._mult_tab = M

    @property
    def container(self):
        return self._container

    @property
    def matrix(self):
        return self._matrix

    @property
    def coeffs(self):
        return self.matrix.flat()

    @property
    def denom(self):
        return self._denom

    @property
    def QQ_matrix(self):
        """Matrix over :ref:`QQ`, equal to ``self.matrix / self.denom``, and always dense."""
        if self._QQ_matrix is None:
            self._QQ_matrix = (self.matrix / self.denom).to_dense()
        return self._QQ_matrix

    def starts_with_unity(self):
        return self(0) == 1

    def element_from_rational(self, a):
        if self.starts_with_unity():
            return self(0) * a
        else:
            return self.container.element_from_rational(a)

    def basis_element_pullbacks(self):
        """Return list of this Submodule's basis elements as elements of the container."""
        return [e.to_container() for e in self.basis_elements()]

    def represent(self, elt):
        """
        Represent a ModuleElement belonging to an ancestor module, as a
        ``ZZ``-linear combination over the generators of this Submodule.

        Parameters
        ==========

        elt: ModuleElement to be represented. Must belong to some ancestor
          module of this Submodule (including this Submodule itself).

        Returns
        =======

        DomainMatrix
            This will be a column vector, representing the coefficients of a
            linear combination.

        Raises
        ======

        ClosureFailure if the given element cannot be represented as an element
        of this Submodule.

        """
        if elt.module == self:
            return elt.column()
        elif elt.module == self.container:
            try:
                # The given element should be a ZZ-linear combination over our
                # basis vectors; however, due to the presence of denominators,
                # we need to solve over QQ.
                A = self.QQ_matrix
                b = elt.QQ_col
                x = A._solve(b)[0].transpose()
                x = x.convert_to(ZZ)
            except DMBadInputError:
                raise ClosureFailure('Element outside QQ-span of this module.')
            except CoercionFailed:
                raise ClosureFailure('Element in QQ-span but not ZZ-span of this module.')
            return x
        elif isinstance(self.container, Submodule):
            coeffs_in_container = self.container.represent(elt)
            container_element = self.container(coeffs_in_container)
            return self.represent(container_element)
        else:
            raise ClosureFailure('Element outside ancestor chain of this module.')

    def is_compat_submodule(self, other):
        return isinstance(other, Submodule) and other.container == self.container

    def __eq__(self, other):
        if self.is_compat_submodule(other):
            return other.QQ_matrix == self.QQ_matrix
        return NotImplemented

    def add(self, other, hnf=True, hnf_modulus=None):
        if self.is_compat_submodule(other):
            d, e = self.denom, other.denom
            m = ilcm(d, e)
            a, b = m // d, m // e
            B = (a * self.matrix).hstack(b * other.matrix)
            if hnf:
                B = hermite_normal_form(B, D=hnf_modulus)
            return self.container.submodule_from_matrix(B, denom=m)
        raise NotImplementedError

    def __add__(self, other):
        try:
            return self.add(other)
        except NotImplementedError:
            return NotImplemented

    __radd__ = __add__

    def mul(self, other, hnf=True, hnf_modulus=None):
        if is_rat(other):
            a, b = get_num_denom(other)
            if a == b == 1:
                return self.copy()
            else:
                return make_submodule(self.container,
                             self.matrix * a, denom=self.denom * b,
                             mult_tab=None).reduced()
        elif isinstance(other, ModuleElement) and other.module == self.container:
            # The submodule is multiplied by an element of the containing module.
            # We presume this means we want a new submodule of the containing module.
            gens = [other * e for e in self.basis_element_pullbacks()]
            return self.container.submodule_from_gens(gens, hnf=hnf, hnf_modulus=hnf_modulus)
        elif self.is_compat_submodule(other):
            # This case usually means you're multiplying ideals, and want another
            # ideal, i.e. another submodule of the same container module.
            alphas, betas = self.basis_element_pullbacks(), other.basis_element_pullbacks()
            gens = [a * b for a in alphas for b in betas]
            return self.container.submodule_from_gens(gens, hnf=hnf, hnf_modulus=hnf_modulus)
        return NotImplemented

    def __mul__(self, other):
        return self.mul(other)

    __rmul__ = __mul__

    def _first_power(self):
        return self.copy()


def is_HNF(dm):
    """
    Say whether a DomainMatrix is in that special case of Hermite normal form,
    in which the matrix is also square and of maximal rank. This is the only
    case that concerns us here.
    """
    if dm.domain.is_ZZ and dm.is_square and dm.is_upper:
        n = dm.shape[0]
        for i in range(n):
            d = dm[i, i].element
            if d <= 0:
                return False
            for j in range(i + 1, n):
                if not (0 <= dm[i, j].element < d):
                    return False
        return True
    return False


class HNF(Submodule):
    """
    A submodule such that:
      * Its container is a PowerBasis.
      * Its number of generators equals the degree of the minimal polynomial
        of the PowerBasis.
      * Its matrix is in square, maximal-rank, Hermite normal form.
    """

    def __init__(self, container, matrix, denom=1, mult_tab=None):
        super().__init__(container, matrix, denom=denom, mult_tab=mult_tab)
        assert isinstance(self.container, PowerBasis)
        assert self.n == self.T.degree()
        assert is_HNF(matrix)

    @property
    def T(self):
        return self.container.T

    def power_basis_elements(self):
        return self.basis_element_pullbacks()

    def pb_elt_from_poly(self, f):
        """
        Produce an element of the PowerBasis, representing a given polynomial
        after reduction mod our defining minimal polynomial ``T``.

        Parameters
        ==========

        f: Poly over :ref:`ZZ` in same var as our defining poly ``T``.

        Returns
        =======

        PowerBasisElement

        """
        return self.container.element_from_poly(f)

    def pb_elt_from_col(self, col, denom=1):
        return self.container(col, denom=denom)


class Order(HNF):
    """
    An order in a number field.

    This is an HNF that includes unity.
    """

    def __init__(self, container, matrix, denom=1, mult_tab=None):
        super().__init__(container, matrix, denom=denom, mult_tab=mult_tab)
        assert self.starts_with_unity()

    @classmethod
    def from_submodule(cls, S):
        return cls(S.container, S.matrix, denom=S.denom, mult_tab=S._mult_tab)


class Ideal(HNF):
    """
    An ideal in a number field.

    This is an HNF that does not include unity.
    """

    def __init__(self, container, matrix, denom=1, mult_tab=None):
        super().__init__(container, matrix, denom=denom, mult_tab=mult_tab)
        assert not self.starts_with_unity()


def make_submodule(container, matrix, denom=1, mult_tab=None):
    """
    Factory function which builds a Submodule, but ensures that it is an
    Order or Ideal as appropriate.
    """
    cls = Submodule
    if isinstance(container, PowerBasis):
        n = matrix.shape[1]
        if is_HNF(matrix) and n == container.T.degree():
            if (matrix / denom)[:, 0].to_dense() == DomainMatrix.eye(n, QQ)[:, 0].to_dense():
                cls = Order
            else:
                cls = Ideal
    return cls(container, matrix, denom=denom, mult_tab=mult_tab)


def make_mod_elt(module, col, denom=1):
    """
    Factory function which builds a ModuleElement, but ensures that it is a
    PowerBasisElement if the module is a PowerBasis.
    """
    if isinstance(module, PowerBasis):
        return PowerBasisElement(module, col, denom=denom)
    else:
        return ModuleElement(module, col, denom=denom)


class ModuleElement(IntegerPowerable):
    """
    Element of a Module.

    NOTE: Should not be constructed directly. Use ``make_mod_elt()`` factory
    function instead.
    """

    def __init__(self, module, col, denom=1):
        """
        Parameters
        ==========

        module: Module
        col: column vector over :ref:`ZZ`

        """
        self.module = module
        self.col = col
        self.denom = denom
        self._QQ_col = None

    def __repr__(self):
        r = str([int(c) for c in self.col.flat()])
        if self.denom > 1:
            r += f'/{self.denom}'
        return r

    def copy(self):
        """Make a copy of this ModuleElement."""
        return type(self)(self.module, self.col.copy(), denom=self.denom)

    def reduced(self):
        """
        Produce a reduced version of this ModuleElement, i.e. one in which the
        gcd of the denominator together with all numerator coefficients is 1.
        """
        if self.denom == 1:
            return self.copy()
        g = igcd(self.denom, *self.coeffs)
        if g == 1:
            return self.copy()
        return type(self)(self.module,
                            (self.col / g).convert_to(ZZ),
                            denom=self.denom // g)

    def reduced_mod_p(self, p):
        """
        Produce a version of this ModuleElement in which all numerator coefficients
        have been reduced mod *p*.
        """
        return make_mod_elt(self.module,
                            self.col.convert_to(FF(p)).convert_to(ZZ),
                            denom=self.denom)

    @classmethod
    def from_int_list(cls, module, coeffs, denom=1):
        """Make a module element from a list of ints (instead of a column vect)."""
        col = to_col(coeffs)
        return cls(module, col, denom=denom)

    @property
    def n(self):
        """The length of this element's column."""
        return self.module.n

    def __len__(self):
        return self.n

    def column(self, domain=None):
        """Get a copy of this element's column, optionally converting to a domain."""
        if domain is None:
            return self.col.copy()
        else:
            return self.col.convert_to(domain)

    @property
    def coeffs(self):
        return self.col.flat()

    @property
    def QQ_col(self):
        """Column vector over :ref:`QQ`, equal to ``self.col / self.denom``, and always dense."""
        if self._QQ_col is None:
            self._QQ_col = (self.col / self.denom).to_dense()
        return self._QQ_col

    def to_container(self):
        """Transform into a ModuleElement belonging to the container of our module."""
        if not isinstance(self.module, Submodule):
            raise ValueError('Not an element of a Submodule.')
        return make_mod_elt(
            self.module.container, self.module.matrix * self.col,
            denom=self.module.denom * self.denom)

    def to_ancestor(self, anc):
        """Transform into a ModuleElement belonging to a given ancestor of our module."""
        if anc == self.module:
            return self.copy()
        else:
            return self.to_container().to_ancestor(anc)

    def over_power_basis(self):
        """Transform into a PowerBasisElement over our PowerBasis ancestor."""
        e = self
        while not isinstance(e.module, PowerBasis):
            e = e.to_container()
        return e

    def is_compat(self, other):
        """Test whether other is another ModuleElement with same module."""
        return isinstance(other, ModuleElement) and other.module == self.module

    def make_compat(self, other):
        """
        Try to make a compatible pair of ModuleElements, one equivalent to this
        one, and one equivalent to the other. This means finding the nearest
        common ancestor Module for the pair of elements, and representing each
        one there.

        Returns
        =======
        Pair of ModuleElements belonging to a common Module, or else the pair
        ``(None, None)`` if no common ancestor could be found.

        """
        if self.module == other.module:
            return self, other
        nca = self.module.nearest_common_ancestor(other.module)
        if nca is not None:
            return self.to_ancestor(nca), other.to_ancestor(nca)
        return None, None

    def __eq__(self, other):
        if self.is_compat(other):
            return self.QQ_col == other.QQ_col
        elif isinstance(other, ModuleElement):
            a, b = self.make_compat(other)
            if a is None:
                return NotImplemented
            return a == b
        elif is_rat(other):
            if isinstance(self, PowerBasisElement):
                return self == self.module(0) * other
            else:
                return self.over_power_basis() == other
        return NotImplemented

    def __add__(self, other):
        """
        A ModuleElement can be added to a rational number, or to another
        ModuleElement.

        When the other summand is a rational number, it will be converted into
        a ModuleElement (belonging to the first ancestor of this module that
        starts with unity).

        In all cases, the sum belongs to the nearest common ancestor (nca) of
        the modules of the two summands. If the nca does not exist, we return
        ``NotImplemented``.
        """
        if self.is_compat(other):
            d, e = self.denom, other.denom
            m = ilcm(d, e)
            u, v = m // d, m // e
            col = to_col([u * a + v * b for a, b in zip(self.coeffs, other.coeffs)])
            return type(self)(self.module, col, denom=m).reduced()
        elif isinstance(other, ModuleElement):
            a, b = self.make_compat(other)
            if a is None:
                return NotImplemented
            return a + b
        elif is_rat(other):
            return self + self.module.element_from_rational(other)
        return NotImplemented

    __radd__ = __add__

    def __neg__(self):
        return self * -1

    def __sub__(self, other):
        return self + (-other)

    def __rsub__(self, other):
        return -self + other

    def __mul__(self, other):
        """
        A ModuleElement can be multiplied by a rational number, or by another
        ModuleElement.

        When the other ModuleElement belongs to the same Module as this one,
        so will the product.

        However, if the other ModuleElement does not belong to the same Module
        as this one, then the resulting product may not belong to the same
        Module as _either_ of the operands. It will belong to their nearest
        common ancestor (NCA) module, if that exists. If the NCA does not
        exist, we return ``NotImplemented``.
        """
        if self.is_compat(other):
            M = self.module.mult_tab()
            A, B = self.col.flat(), other.col.flat()
            n = self.n
            C = [0] * n
            for u in range(n):
                for v in range(u, n):
                    c = A[u] * B[v]
                    if v > u:
                        c += A[v] * B[u]
                    if c != 0:
                        R = M[u][v]
                        for k in range(n):
                            C[k] += c * R[k]
            d = self.denom * other.denom
            return self.from_int_list(self.module, C, denom=d)
        elif isinstance(other, ModuleElement):
            a, b = self.make_compat(other)
            if a is None:
                return NotImplemented
            return a * b
        elif is_rat(other):
            a, b = get_num_denom(other)
            if a == b == 1:
                return self.copy()
            else:
                return make_mod_elt(self.module,
                                 self.col * a, denom=self.denom * b).reduced()
        return NotImplemented

    __rmul__ = __mul__

    def _zeroth_power(self):
        return self.module.one()

    def _first_power(self):
        return self.copy()

    def __floordiv__(self, a):
        if is_rat(a):
            a = QQ(a)
            if a == 0:
                raise ZeroDivisionError
            return self * (1/a)
        return NotImplemented

    def __mod__(self, a):
        r"""
        Reducing mod an integer *a* reduces all numerator coeffs mod $d a$, where
        $d$ is our denominator.

        For example, if we represent

        $$ \frac{15 a_1 + a_0}{2} = \frac{a_1 + a_0}{2} + 7 a_1 $$

        then reducing mod 7 should mean throwing away that part that is a poly
        in the basis elements $a_i$, with content divisible by 7. But this is
        achieved by reducing our coeffs mod $2 \times 7$.
        """
        if is_int(a):
            m = a * self.denom
            col = to_col([c % m for c in self.coeffs])
            return type(self)(self.module, col, denom=self.denom)
        return NotImplemented


class PowerBasisElement(ModuleElement):
    """
    Subclass for ModuleElements whose module is a PowerBasis.
    """

    @property
    def T(self):
        return self.module.T

    def numerator(self, x=None):
        """Obtain the numerator as a polynomial over :ref:`ZZ`."""
        x = x or self.T.gen
        return Poly(reversed(self.coeffs), x, domain=ZZ)

    def poly(self, x=None):
        """Obtain the number as a polynomial over :ref:`QQ`."""
        return self.numerator(x=x) // self.denom

    def norm(self, T=None):
        """Compute the norm of this number."""
        T = T or self.T
        x = T.gen
        A = self.numerator(x=x)
        return T.resultant(A) // self.denom ** self.n

    def inverse(self):
        f = self.poly()
        e, h = f.invert(self.T).clear_denoms()
        return self.module.element_from_poly(h) // ZZ.from_sympy(e)

    def __rfloordiv__(self, a):
        return self.inverse() * a

    def _negative_power(self, e, modulo=None):
        return self.inverse() ** abs(e)


class ModuleHomomorphism:
    """A homomorphism from one module to another."""

    def __init__(self, domain, codomain, mapping):
        self.domain = domain
        self.codomain = codomain
        self.mapping = mapping

    def matrix(self, modulus=None):
        """Compute the matrix of this homomorphism."""
        basis = self.domain.basis_elements()
        cols = [self.codomain.represent(self.mapping(elt)) for elt in basis]
        if not cols:
            return DomainMatrix.zeros((self.codomain.n, 0), ZZ).to_dense()
        M = cols[0].hstack(*cols[1:])
        if modulus:
            M = M.convert_to(FF(modulus))
        return M

    def kernel(self, modulus=None):
        """
        Compute a matrix whose columns form a basis for the kernel of this
        homomorphism.
        """
        M = self.matrix(modulus=modulus)
        if modulus is None:
            M = M.convert_to(QQ)
        # Note: Even when working over a finite field, what we want here is
        # the pullback into the integers, so in this case the conversion to ZZ
        # below is appropriate. When working over ZZ, the kernel should be a
        # ZZ-submodule, so, while the conversion to QQ above was required in
        # order for the nullspace calculation to work, conversion back to ZZ
        # afterward should always work.
        K = M.nullspace().convert_to(ZZ).transpose()
        return self.domain.submodule_from_matrix(K)


class ModuleEndomorphism(ModuleHomomorphism):
    """A homomorphism from one module to itself."""

    def __init__(self, domain, mapping):
        super().__init__(domain, domain, mapping)


class InnerEndomorphism(ModuleEndomorphism):
    """
    An inner endomorphism on a module, i.e. the endomorphism corresponding to
    multiplication by a fixed element.
    """

    def __init__(self, domain, multiplier):
        super().__init__(domain, lambda x: multiplier * x)
        self.multiplier = multiplier


class EndomorphismRing:
    """The ring of endomorphisms on a module."""

    def __init__(self, domain):
        self.domain = domain

    def inner_endomorphism(self, multiplier):
        return InnerEndomorphism(self.domain, multiplier)

    def represent(self, element):
        if isinstance(element, ModuleEndomorphism) and element.domain == self.domain:
            M = element.matrix()
            # The purpose of this method is to produce a column vector (which
            # can be included as a column in a matrix representing a linear map).
            # So must transform the matrix we compute into a single column,
            # which should reproduce the original columns, one after another.
            m, n = M.shape
            if n == 0:
                return M
            return M[:, 0].vstack(*[M[:, j] for j in range(1, n)])
        raise NotImplementedError


def find_min_poly(alpha, domain, x=None, powers=None):
    """
    Find a polynomial of least degree (not necessarily irreducible) satisfied
    by an element of a finitely-generated ring with unity.

    Parameters
    ==========

    alpha: ModuleElement whose min poly is to be found, and whose module has
        multiplication and starts with unity.

    domain: The desired domain of the polynomial.

    x: (optional) desired variable for the polynomial.

    powers: (optional) If desired, pass an empty list. The powers of alpha
        (as ModuleElements) from the zeroth up to the degree of the min poly
        will be recorded here, as we compute them.

    Returns
    =======

    Poly, being the minimal polynomial for alpha, or ``None`` if no polynomial
        could be found over the desired domain.

    Raises
    ======

    ValueError
        If the module to which alpha belongs does not start with unity.
    ClosureFailure
        If the module to which alpha belongs is not closed under multiplication.

    """
    R = alpha.module
    if not R.starts_with_unity():
        raise ValueError("alpha must belong to finitely generated ring with unity.")
    if powers is None:
        powers = []
    one = R(0)
    powers.append(one)
    powers_matrix = one.column(domain=domain)
    ak = alpha
    m = None
    for k in range(1, R.n + 1):
        ak_col = ak.column(domain=domain)
        try:
            X = powers_matrix._solve(ak_col)[0]
        except DMBadInputError:
            # This means alpha^k still isn't in the domain-span of the lower powers.
            powers_matrix = powers_matrix.hstack(ak_col)
            powers.append(ak)
            ak *= alpha
        else:
            # alpha^k is in the domain-span of the lower powers, so we have found a
            # minimal-degree poly for alpha.
            coeffs = [1] + [-c for c in reversed(X.to_list_flat())]
            x = x or Dummy('x')
            if domain.is_FF:
                m = Poly(coeffs, x, modulus=domain.mod)
            else:
                m = Poly(coeffs, x, domain=domain)
            break
    return m
